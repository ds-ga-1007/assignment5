Questions
Note: Use the file name and line number when referring to locations in the code.
1.	Describe the changes you made to make the game work with Python 3
I replaced raw_input with input in the adventure.py program, because this is a difference between Python 2 and Python 3.
2.	Describe three main techniques that the author used to structure the program.
(1)	Modules for a separation of concerns: The author separated the program into distinct modules that are intended to separate and clarify the different concerns. The modules are as follows:
a.	Model: creates classes for the features of the game
b.	Play: Creates functions “load_advent_dat,” (line 3) “play” (line 11) and “resume” (line 29). These functions relate to starting and stopping the game.
c.	Game: Tracks the state of the game. The state of the game is determined by 16 variables (lines 21-37) that track how many moves in each direction the user has made, how many objects they have found, and other aspects of the game. This module populates the variables at the start of the game. It also changes the values of the variables if the player performs an action, and it calculates the player’s ongoing “score” (line 1649). 
d.	Adventure: This module concerns starting the game and retrieving saved games.
e.	Prompt:  This module establishes “routines that install Adventure commands for the Python prompt.”
f.	Data: The author says it “Parses the original PDP advent.dat file.” The Data class has methods for 12 sections and a parse method that uses a while loop to handle each section.
(2)	Classes to organize structural and behavioral components. Many of these are created in the model.py program. For example, on line 103, the “object” class is an item that can be used in game play. It has variables associated with it like is_fixed, is_treaure, etc. that determine what this object is and what can be done with it. It also creates a lot of methods that can be performed on an object. For example, an object can be dropped, hidden, destroyed, or carried using these methods.
(3)	Functions to structure the tasks that are performed in the code. The play and adventure modules are very short, and they define functions that run some of the overarching activities of the game.
3.	Has the author used meaningful names? Give some examples of meaningful names used and what you think they mean. Give some examples of where the author has not used meaningful names.
The author has tried to use meaningful names, but not all the names are meaningful.
In the data.py module, on line 24, the author has created a class called “Data” with several methods that can be performed on the Data class. The names of many of these methods are simply “section1”, “section2”, “section3” etc. We’re missing context here. What is this a section of? We would also expect the name of a method to be a verb or verb phrase. What task is being performed on the section? Also, the methods for this class use a lot of variables named by a single letter (m, n, y, or x). These are not searchable, and they don’t carry any meaning for other programmers.
An example of effective naming is in the model.py class definition for the “Dwarf” class. This is at line 165. It’s very clear what the dwarf class represents, and it’s very searchable and pronounceable. The methods can_move and start_at are also clear.
4.	Do the functions used in the code do one thing? Give some examples of functions that only do one thing. Give some examples of functions that do more than one thing.
Most of the functions used in the code do more than one thing. While not the longest function in the program, the function “score_and_exit” at the end of game.py (line 1698) clearly does at least two things (score and exit). It computes the score (1), tells the player their score (2), computes how the score ranks relative to other scores (3), tells the player how the score ranks relative to other scores (4), and makes is_done=true (finishes) (5).
The “loop” function in the adventure.py module on line 19 also contains a lot of different steps. It passes an argument to parser (1), adds an argument to parser (2), calls a function on parser and passes it to “args” (3), performs several different steps conditional on properties of “args” (4-9), and performs a while loop (9-12).
There are some functions that only do one thing. As part of the object class on line 127 of model.py, is_at() just returns the room where the object is. Similarly, destroy() just hides the object.
5.	Do any of the functions cause side effects? If so, which ones?
The I_Score function at line 1433 causes some side effects. Based on the name and the first few lines of code, the main effect is to compute the score and deliver a message to the player about their current score, without exiting. However, under certain conditions, the function also calls score_and_exit() which exits the game. To a programmer executing this function expecting it to merely compute the score, this would be an unexpected behavior or side effect.
6.	Can you find any repeated code that could be made into a function?
The author used a lot of functions, and there aren’t large chunks of code repeated. There are a few very small repeated pieces of code. For example, there are 2 places in the game module where the code includes:
“if self.bear.is_toting:
	Self.write_message(141)”
You could make this a function that writes a message when the condition holds. Since it only appears twice and the code is short, it’s understandable that the author didn’t do so.
7.	Does the program use exception handling? Can you find any input that causes the program to terminate abnormally? Hint: run the program from the terminal prompt. The invalid input may not be normal text.
The program uses some exception handling. You can see in the adventure module a loop that accepts input and a use of the EOFERROR built-in exception. The game can take most incorrect inputs and says “what?” or “I don’t know that word” in most cases. When you input a symbol, it doesn’t respond, but it also doesn’t cause an abnormal termination. Entering large chunks of text causes the program to return a response to each line one by one. There may be a way to cause the program to terminate abnormally, since the EOFERROR exception is the only one explicitly handled in the code.
8.	Do any of the classes have responsibility over more than one piece of functionality. If so, which ones?
Yes, the game module is one huge class called Game. This would be much more manageable if it were broken out into smaller classes. It has responsibility over the number of deaths and keeping track of how many times the player has died, how many dwarves have been killed, how many treasures have been found, etc.
9.	Are all the classes cohesive? List any that aren’t.
For a class to be cohesive, it should maintain fairly few attributes, each method should manipulate one or more instance variables, and you shouldn’t have classes with many variables that are only used by a subset of methods.
Not all of the classes are cohesive. The game module is not very cohesive. Many variables are only used by a subset of methods. There are many methods in this class, probably over 100. The variable “bonus” is used only in 2 methods, t_blast(), and maxscore(). Similarly, is_dead is only used in _do_command(), die(), and callback().
Similarly, many methods only use a small handful of variables. For example, t_blast only uses bonus of the instance variables. I_brief only uses look_complaints and full_description period.
The class isn’t dedicated to a narrowly defined purpose, so it makes sense that many of the components of the class aren’t united by a common task, and they aren’t operating on the same data.
Data seems more cohesive than game, but it also exhibits some of the same problems.
10.	Describe the author’s approach to commenting the code. Provide examples of good and bad comments that have been used in the code.
The author comments somewhat sparingly. The author often uses comments as headings or descriptions, but sometimes they aren’t specific enough. In the game module, the author uses numeric comments referring to FORTRAN lines.
The game module includes some bad comments. On line 112 in the game module, the author leaves a comment “game startup.” There’s another redundant comment on line 115 “start the game.” The comment on line 124 is “set things going” which is also vague and redundant. The method is called “start” so these comments aren’t much more helpful than the method name.
There are some good comments in the data module. The author provided some comments that serve as an “explanation of intent” in the data module. On line 1, the author says “Parse the original PDP ‘’advent.dat’’ file.” And on lines 6 & 7, he/she says “The adventure data file knows only the first five characters of each word in the game, so we have to know the full version of each word.” This is a warning of consequences, which is also a good type of comment. These comments give an overarching picture of the purpose of the code that, even with clean code, would be hard to quickly grasp.
11.	Provide an example of where vertical formatting has been used to make the code clearer.
Proper vertical formatting places a blank line to identify a new & separate concept. Variables should be declared close to where they are used, related functions should appear close to each other, and dependent functions go below functions that call the dependent function. Most of these principles are used in the code.
The data module demonstrates an effort to use proper vertical formatting. The author identifies “helper functions” on line 38 and then uses those in the functions that follow on line 59. This follows the principles that dependent functions go below functions that call the dependent function, and related functions should appear close to each other. Each method is separated from the method below with a blank space to identify a new & separate concept.
12.	Run the tests provided with the program. Do they pass or fail? Do you consider the tests meet the F.I.R.S.T. criteria? Provide details of why they do or do not meet the criteria.
I could run the tests once I put the python modules and the tests in the same folder (otherwise, terminal can’t find the necessary files). I didn’t encounter an error when I ran these tests, so they did not explicitly fail, but I question the tests because they don’t meet the F.I.R.S.T. criteria.
The F.I.R.S.T. criteria requires that the tests should be fast, independent (can be run in any order), repeatable, self-validating (tests should either pass or fail or the test becomes subjective), timely (written during code development, not after program is completed). 
These tests pass the first 3 criteria (fast, independent, repeatable). It’s hard to say for sure if they were created in a timely way, since I don’t know when the author wrote them. They aren’t, however, self-validating. The test functions don’t explicitly instruct the program to raise an error based on the outcome of the test, so assessing whether the program “passed” the test becomes subjective.
