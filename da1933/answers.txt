1. Referring to the python 3 documentation here (https://docs.python.org/3.1/tutorial/interpreter.html), I opened the file with the command, “exec(open(‘adventure.py’).read())” and the following error was thrown: “NameError: ‘raw_input’ is not defined.”  The documentation indicated that raw_input is not used in python 3. Therefore, in LINE 37 I changed ‘raw_input’ to ‘input’ and the game then operated without any trouble.

2. This is a textual game, and its basic components are lines that describe a player’s location, possessions, actions, options, limitations, etc.  These components must interact and flow logically depending on the choices that the user makes.  In order to keep track of the player’s progress, lives, points, items, and narrative options that the player has, the author used Functions, Modules, and Classes.  Functions in the adventure.py module are responsible for outputting the proper information for the user to interact with, but they are also included throughout the code in order to perform all sorts of tasks; the game.py module is essentially one enormous Class that keeps track of nearly all of the user’s potential actions, locations, interactions, viewable comments, etc.; the model.py module houses additional classes of various entities in the game, including movement, objects, rooms, characters, and even certain types of messages (like hints); finally, the play.py module loads a new or saved game and links the actual text from data modules to the states determined in game.py.

3. The author uses both meaningful and meaningless names.  For example, “resume” (play.py LINE 29) is a function that resumes a saved game, and “Room” (model.py LINE 38) that defines all the possible locations and their various attributes. Further more, the move_dwarves function has variables such as “dwarf.room” (game.py LINE 237), “dwarf_attacks” (game.py LINE 301), and “dwarf.has_seen_adventurer” (game.py LINE 230) that make the code’s objectives quite clear.  On the other hand, he uses functions and variables names such as “section_”, “n”, “m”, “mm”, “mh”, “divmod”, “x”, and “y” (data.py LINES 57, 74, 75, 75, 74, 67, 67, respectively) that offer not meaning whatsoever without reading the code very carefully.

4. Some functions do one thing and some functions do more than one thing.  Some examples of functions that do just one thing are “random” (game.py LINE 57), “choice” (game.py LINE 60), “inventory” (game.py LINE 88), which all simply return specific information.  However, “move_dwarves” (game.py LINE 188) performs dwarf moves, keeps track of the dwarf_stage and dwarf_attacks (both of which influence the function in a different location), determine the pirate behavior, and more.  The “loop” function (adventure.py LINE 19) loads games and also outputs the input line and command words.

5. Output arguments carry the risk of causing side effects, and the programmer implements them (data.py LINE 40) in this game.

6. The “play” function (play.py LINE 11) and the “resume” function (play.py LINE 29) are very similar, with the major difference being that “play” starts a new game and “resume” resumes a saved game.  Many of the lines in these functions are repeated, so it’s possible that you could have a different function that starts a game, and have that function refer to a separate function that determines if a saved game is present.  This would eliminate some repetition.

7. The program handles most types of inputs, but does exits upon receiving ctrl+c.

8. The class Game (game.py LINE 19) is enormous and has responsibility over several pieces of functionality, including generating random numbers, handling the user’s inventory, the objects present around, starting the game, and determining the narrator’s responses, just to name a few.

9. Some of the classes are cohesive like most of those defined in model.py LINES 82, 145, and 152.  The Game class (game.py LINES 19-1713) is not cohesive.  It combines a lot of elements in it that have absolutely nothing to do with one another, e.g. “score_and_exit” (game.py LINES 1698-1713) and “move_dwarves” (game.py LINES 118-321). 

10. The author’s commenting style is a little erratic; at times he uses apt variable names to obviate commenting, and though he sometimes provides comments to clarify the purpose of code, he leaves them out for the majority of functions and this seems inconsistent.  It often feels as though he wrote comments for himself as reminders, instead of writing them for other programmers.  An example of bad commenting is in the “dont_understand” function (game.py LINE 612) which operates based on a random number and has comments such as “# 20% of the entire 1.0 range of random()”, but has no comment that provides greater context and tells you how this function fits into the program.  There are also superfluous comments such as the variables at the top of the Game class where he comments variables such as “max_deaths” and “is_dead”, (game.py LINES 36, 34) which are very obvious.  It seems as though he began commenting at the beginning of the file and then decided to stop.
Examples of good comments are “#protect against caller changing list” (prompt.py LINE 10) and game.py LINES 148-151, which explain intent.

11. game.py LINES 809-832 are a good example of vertical programming, in which he lists a group of variables set by input messages and then defines a series of functions to handles those given inputs.  The names are close to where they will be used, and listing them together prepares the reader for the next set of functions, so this is a good example of vertical programming.

12. The tests do not pass.  With respect to the F.I.R.S.T. criteria, it took 0.137 seconds to run 13 tests.  Whether or not that is technically fast depends on benchmarks of average testing speed which I don’t have access too.  The tests are independent and can be run in any order.  The tests are also both Repeatable and Self-validating. With respect to timeliness, in a limited sense I could say that the tests seem to be written such that they could be used throughout development on the commands, data, and walks, but I have no proof that the tests were actually written during development as opposed to after the program was complete.


