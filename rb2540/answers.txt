1. In the file "adventure.py" on line 37, the function "raw_input"()" was changed to "input()". In Python 3, there is no "raw_input()" function and “input()" is used instead. 

2. The author uses modular programming, as the program is composed of several modules that are somewhat logically discrete. He also utilizes classes and the single responsibility principle (to an extent) in the code—-while the responsibilities of some classes are broader than others, they are encapsulated by the class and the names of the classes describe their responsibility. The author also makes use of cohesion (to an extent) in that there is a strong relationship between the elements and functionality within each given module.

3. In general, the author does use meaningful names. Many of the variables have names that reference real things in the game. For example, “dwarves_killed” stores the number of dwarves that have been killed (game.py, line 25) and “is_dead” is a variable that stores a boolean value indicating whether the player is currently dead or not (game.py, line 34). One instance where names were used that are not meaningful occurs in “adventure.py” line 14. The iterator and sequence variables in this for loop are simply named ‘c’ and ’s’. This doesn’t give us any information about the sequence we are iterating over, or what each value of the sequence represents. Additionally, in “data.py” there are several functions that begin with the name “section”. Because these names are generic, it is not immediately clear what these sections represent.

4. Some of the functions do one thing, and many do not. In “game.py”, the functions on lines 88, 92, 96, and 99 all do one thing only. These functions contain only a return statement and utilize other functions in these return statements in order to only do one thing each. For instance, the function “objects_here()” simply returns the objects at the location. In the same file, the “start()” function on line 114 does multiple things: it allows 5-letter words to be accepted, it initializes several variables that represent the starting states of objects in the game, and it handles whether to give the player instructions or not. “game.py” line 72 contains a function “yesno()” that also does multiple things: it asks a question and prepares to receive an answer. This function also has 4 arguments, which should be avoided. 

5. In the file “play.py”, the functions “play()” and “resume()” on lines 11 and 29 cause side effects, by definition, because they use assignments to a global variable. They both contain assignment statements that modify the variable “_game”. 

6. In “game.py” several functions contain code to write messages that relay information about scoring. It seems as though instead of using the same functions and write() statements in all these functions, the code could be handled by additional functions.

7. The program uses exception handling in a few cases but does not use it in most cases. I have found that when using certain ascii characters, the program quits abruptly. Specifically, when using the symbol entered with the keys “ctrl-shift” at any prompt, the program exits. 

8. The class “Game” in the file “game.py” is responsible for a lot of the functionality within the game, and certainly is responsible for more than one piece of functionality. The class stores many important attributes for the game, handles message writing, 
starting the game, scoring, exiting the game, and more. 

9. The “Game” class mentioned above has low cohesion for similar reasons. This class has a large number of instance variables, many of which are only used by a subset of methods. Also, because this class has many different purposes that aren’t all closely related, it generally has low cohesion. 

10. An example of a good comment is in the file “data.py” on line 199. This comment plainly describes the intent of the function and is very straightforward. An example of a bad comment is on line 131 of “game.py”. It says “Display instructions if the user wants them.” The reason I think this comment is bad is because the naming of surrounding functions and variables could be better to make the functionality clearer without this comment. The function itself is called “start2” which is pretty arbitrary compared to the previous “start” function. Additionally, the function “start2” takes a boolean argument called “yes” that determines whether or not the user wants instructions, but the code would be clearer if the variable was called something like “giveInstructions”, or at least something more related to what the function is doing. 

11. The Game class in “game.py” makes use of vertical formatting to make the code clearer in many places. All of the instance variables are declared close together at the top. Also, there are blank lines included between all of the functions, and even within functions to separate areas of code that aren’t related. 

12. The tests all passed on the adventure code. We will run through the F.I.R.S.T. criteria. The tests ran in under 8 seconds, which seems relatively fast. The tests do appear to be independent and can run in any order. They are also repeatable and don’t seem to have any environment-dependent issues. Each test can definitively pass or fail so they are self-validating. Finally, I don’t know for sure when the tests were written, but they seem to have been written by the developer of the game code, so it would seem that they were written around the time of development. Based on this analysis, I do believe that the tests meet the F.I.R.S.T. criteria. 